# Core Drift Assessment against Authority Statements (2026-02-14)

## Scope

This note compares the current `core/` implementation with the provided authority statements.

## Drift Matrix

### 1) Capability payload schema and Act payload JSON

- **Authority**: Capability has payload schema; Act payload must be JSON.
- **Current**: `EndpointCapabilityDescriptor` includes `payload_schema`, and `Act` uses `normalized_payload: serde_json::Value`.
- **Assessment**: **No drift** (already aligned).

### 2) Sense/Act/Capability should be declared under Cortex

- **Authority**: Sense, Act, Capability all should be declared by Cortex.
- **Current**:
  - `Sense` and `Act` are declared in `runtime_types.rs`, not under `cortex/`.
  - Capability route/descriptor domain is primarily under `spine::types`.
  - Cortex has its own `CapabilityCatalog` projection (`AffordanceCapability`) bridged from Spine catalog.
- **Assessment**: **Drift** (domain ownership split across `runtime_types`, `spine`, and `cortex`).

### 3) Separate endpoint-id and endpoint-name; id assigned by Spine on registration; name is semantic and deduped (`cli.1`, `macos-app.2`)

- **Authority**: Endpoint id is UUID allocated by Spine at registration; endpoint name is semantic, body-declared, and deduped by Spine with monotonic suffix.
- **Current**:
  - Route key uses only `endpoint_id` + `capability_id`; there is no first-class `endpoint_name` field.
  - For remote registration, endpoint identity is provided by client data in descriptor route (`endpoint_id`), not generated by Spine.
  - No monotonic endpoint-name collision strategy exists.
- **Assessment**: **Drift** (missing name/id split and Spine-side id allocation policy).

### 4) Capability scope and identity

- **Authority**: Capability is scoped within body endpoint; capability id is semantic natural language and singleton.
- **Current**:
  - Capabilities are scoped by `RouteKey { endpoint_id, capability_id }`, and registry enforces unique capability id within endpoint.
  - Native endpoint bootstrap registers multiple capabilities under one endpoint (e.g. `cap.core`, `cap.core.lite`, `cap.core.minimal`).
- **Assessment**: **Partial drift**:
  - Scope uniqueness is aligned.
  - But current naming style is code-like ids; “singleton semantic capability per endpoint” is not modeled as an explicit invariant beyond unique route key.

### 5) Spine API surface: adapter-facing API and internal API split

- **Authority**:
  - Adapter-facing API includes endpoint/capability registration and `put sense`.
  - Adapter has `start`, `stop`, `dispatch acts`.
  - Spine internal API includes `start`, `on acts`, `stop`.
  - Endpoint/capability changes should flow via sense queue.
  - Spine is global singleton.
- **Current**:
  - Spine singleton exists (`install_global_executor` + `global_executor`).
  - Endpoint/capability changes are currently applied directly to registry and *also* mirrored to sense queue (`new_capabilities`/`drop_capabilities`) for continuity updates.
  - Unix adapter exposes a single `run` loop rather than explicit lifecycle + dispatch traits.
  - No explicit `Spine::start/on_acts/stop` API boundary.
- **Assessment**: **Drift** (API contracts and queue authority ordering are not yet in target shape).

### 6) Body endpoints should talk to adapters only, not Spine directly (core internal endpoints via inlineAdapter)

- **Authority**: Any body endpoint communicates with adapter, never directly with Spine.
- **Current**:
  - In-process standard endpoints and native endpoints are directly registered to `EndpointRegistryPort` in `main`/`stem`, bypassing an inline adapter abstraction.
- **Assessment**: **Drift** (missing inline adapter boundary and direct-registration bypass exists).

### 7) Adapter as Spine API translation (transport/app protocol layering)

- **Authority**: Adapter translates Spine API over transports (protobuf/ws, ndjson/unix socket); application layer remains Rust struct/trait model.
- **Current**: Unix socket adapter performs translation to wire JSON and back; Rust domain structs remain central.
- **Assessment**: **Partial drift** (concept exists, but adapter contract is implicit and not formalized as reusable adapter port set).

### 8) NDJSON over Unix Socket wire format

- **Authority**:
  - fields: `method` (sense/act/auth), `id` (uuidv4), `timestamp` (UTC ms), `body`
  - body endpoint can send only `sense`, `auth`; adapter can send only `act`.
- **Current**:
  - Uses tagged JSON field `type` with values such as `sense`, `new_capabilities`, `drop_capabilities`, `body_endpoint_register`, `body_endpoint_unregister` and outbound `act` envelope.
  - No required message envelope fields `id` or `timestamp`.
  - No explicit `auth` method.
- **Assessment**: **Major drift** (wire envelope and method taxonomy differ significantly).

### 9) In-core body endpoints startup ordering

- **Authority**: In-core body endpoints are conditionally started by `main`, after Spine start and before Stem start.
- **Current**:
  - `main` creates registry, registers default native + std body endpoints, then installs global spine executor, then starts stem.
- **Assessment**: **Minor drift** (ordering is close but not exactly “Spine started first”; endpoint startup happens before spine singleton install).

## Proposed Plan to Address Drifts

1. **Define canonical Cortex-owned contracts (P0)**
   - Move or alias `Sense`, `Act`, and capability declaration contracts into a Cortex-domain contract module.
   - Keep compatibility re-exports to minimize immediate breakage.

2. **Introduce endpoint identity model (P0)**
   - Add `EndpointIdentity { endpoint_uuid, endpoint_name }`.
   - Implement Spine-side endpoint UUID allocation and monotonic endpoint-name dedupe.
   - Persist/track monotonic suffix counter per base endpoint name.

3. **Refactor Spine registration pipeline to sense-authoritative flow (P0)**
   - Change registration/update/remove so source of truth transitions through sense queue processing.
   - Ensure registry mutation happens in one authoritative stage (likely Stem/Spine control stage), not both adapter + sense mirror.

4. **Formalize adapter traits and lifecycle (P0/P1)**
   - Introduce adapter port trait set: `start`, `stop`, `dispatch_act` (+ optional session hooks).
   - Rework Unix adapter to implement this trait; keep current behavior behind compatibility shim during migration.

5. **Create inline adapter for in-process body endpoints (P1)**
   - Add `InlineAdapter` so std/native endpoints register and receive acts through adapter contract instead of direct registry writes.
   - Route all body endpoint interactions through adapter boundary to satisfy architecture rule.

6. **Wire protocol v2 for NDJSON Unix socket (P1)**
   - Add envelope: `method`, `id` (uuidv4), `timestamp`, `body`.
   - Add `auth` flow, enforce direction constraints (`sense/auth` inbound from body, `act` outbound from adapter).
   - Keep temporary dual-stack parser (v1 + v2) gated by config for migration safety.

7. **Capability singleton semantics tightening (P2)**
   - Clarify and enforce the intended “singleton capability” invariant in data model and validation (if required beyond route uniqueness).
   - Align naming expectations for human-semantic capability ids.

8. **Boot sequencing cleanup (P2)**
   - Make Spine explicit lifecycle start happen before in-core endpoint startup and before Stem start.
   - Document order in module docs and add startup-order tests.

9. **Migration & validation hardening (P0-P2)**
   - Add conformance tests for:
     - endpoint id/name assignment
     - NDJSON envelope correctness and auth
     - adapter-only body endpoint path
     - sense-authoritative registry transitions
   - Ship with feature flags and staged rollout notes.
